---
title: "data_manipulation"
output: github_document
date: "2025-09-18"
---

```{r}
library(tidyverse)
```


Import datasets:

```{r}
litters_df =
  read_csv("data/FAS_litters.csv", na = c("NA", ".", ""))

litters_df=
  janitor::clean_names(litters_df)

pups_df = 
    read_csv("data/FAS_pups.csv", skip = 3,na = c("NA", ".", ""))

pups_df=
    janitor::clean_names(pups_df)
```

## `select()`

`select`  selects variables from a dataframe

Select Specific Variables
```{r}
select(litters_df, group, litter_number, gd0_weight)
```

Select a range of variables 
```{r}
select(litters_df, group:gd_of_birth)
```

Select by Removal
```{r}
select(litters_df, -group)
select(litters_df, -(group:gd_of_birth))
```

Select by prefix (`starts_with` is what he uses most often, but there also `ends_with` or `contains`)
```{r}
select(litters_df, group, starts_with("gd"))
```

Rearrange by selecting.

What comes first in the command is what is going to come first in the output. 
```{r}
select(litters_df, starts_with("gd"), group)
select(litters_df, litter_number, everything())
#^second command outputs litternumber first and then outputs everything first

relocate(litters_df, litter_number)
#this does the exact same thing as command two in this section
```

Rename by selecting
```{r}
select(litters_df, GROUP = group, everything())
#GROUP is the new name for group
rename(litters_df, GROUP = group)
#Also does the same thing
```

What if I only select one variable...?
```{r}
select(litters_df, group)
#this is not a vector. It is still a dataframe. Unlike what pull() produces...

pull(litters_df, group)
#he hardly ever ues pull (pulling something out of a dataframe)
#pull produces a vector

```

Theoretically you can do something like `litters_df$group` which pulls the variable out of the dataframe. But this is a clunky, BAD FORM OF CODING

### Learning Assessment 

```{r}
select(pups_df, litter_number:pd_ears)

#Alternatively you can do:
select(pups_df, litter_number, sex, pd_ears)
```


## `filter()`

Use `filter()` to filter out rows
```{r}
filter(litters_df, gd_of_birth == 20, pups_born_alive == 6)

#== means check if. If = 20, include. if does not = 20, do not include
```

Look for more than five pups alive

```{r}
filter(litters_df, pups_born_alive > 5)
filter(litters_df, pups_born_alive >= 5)
filter(litters_df, pups_born_alive <= 5)
```

Look for non matches

```{r}
filter(litters_df, pups_born_alive != 6)

#!= means check if. If does not = 6, include. if = 6, do not include
```

match to a set

```{r}
filter(litters_df, group %in% c("Con7","Con8"))
#by using %in%, this looks at rows that only have values in group column equal to Con7 or Con8
```


Filter out rows with missing rows with `drop_na()`
```{r}
drop_na(litters_df)

#you can specify if you want to filter for only missing variables 
drop_na(litters_df, gd0_weight)
```

### Learning Assessment 2
```{r}
filter(pups_df, sex == 1)
filter(pups_df, pd_walk < 11, ,sex == 2)
```


## `mutate()`

use `mutate()`to create or modify variables 

```{r}
mutate(
  litters_df,
  wt_gain = gd18_weight - gd0_weight,
   group = str_to_lower(group)
)

#str_to_lower updates group variable to make everything lower case
```


## `arrange()`

`arrange()` arranges things ....lol

```{r}
arrange(litters_df,pups_born_alive)
arrange(litters_df, group, pups_born_alive)
#can nest the sorting

arrange(litters_df, desc(group), pups_born_alive)
#desc() switches the order from ascending to descending. Default is ascending order
#^in this example, group will take priority and be sort by descending order first and then pups_born_alive will be sorted next by ascending order

#NA values will go at the bottom regardless of if you sort asc. or desc.
```


## PIPES!!

First, look at a VERY bad way of doing things

```{r}
#THIS IS A SUPER CLUNKY. DONT DO THIS!
litters_df =
  read_csv("data/FAS_litters.csv", na = c("NA", ".", ""))

litters_df =
  janitor::clean_names(litters_df)

litters_df = 
  seelct(litters_df, group, litter_number, starts_with("gd"))

litters_df = 
  drop_na(litters_df)

litters_df = 
  mutate(
    litters_Df,
    wt_gain = gd18_weight - gd0_weight
  )
```


Another way of doing this super poorly 

```{r}
#THIS IS A SUPER CLUNKY. DONT DO THIS!
litters_df = 
  mutate(
    drop_na(
      seelct(
        janitor::clean_names(
          read_csv("data/FAS_litters.csv", na = c("NA", ".", ""))), 
          group, litter_number, starts_with("gd"))),
    wt_gain = gd18_weight - gd0_weight
  )
```

Use pipes to avoid all of this:

Use command + shift + M to get pipe operator

```{r}
litters_df =
  read_csv("data/FAS_litters.csv", na = c("NA", ".", "")) |> 
  janitor::clean_names() |> 
  select(group, litter_number, starts_with("gd")) |> 
  drop_na() |> 
  mutate(
    wt_gain = gd18_weight - gd0_weight
  )

#with this form, you dont need to keep writing litters_df. For example, with select() you dont need to reference litters_df before you say what variables you want to select. 
#if you want to see the output before creating the df, run everything inside (after litters_df=) to get the output as you go
```


## Learning Assessment 3

```{r}
pups_df = 
  read_csv("data/FAS_pups.csv", skip = 3,na = c("NA", ".", "")) |> 
  janitor::clean_names() |> 
  filter(sex == 1) |> 
  select(-pd_ears) |> 
  mutate(
    pivot_ge7 = pd_pivot >= 7
  )

#Sometimes steps can go in any other. But sometimes order matters. For example, you cannot do select(-pd_ears)  before janitor::clean_names() because until janitor::clean_names() happens, pd_ears does not exist. (Recall, in the original data file, the variable name has spaces and janitor converts names to snake case)
  
```

To make a linear model:

```{r}
lm(wt_gain ~ gd_of_birth, data = litters_df)

#one example in where tidyverse command puts df NOT at the very front 
```




